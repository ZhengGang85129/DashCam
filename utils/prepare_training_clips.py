import os, sys
from multiprocessing import Pool
sys.path.append(os.getcwd())
import pandas as pd
import numpy as np
from typing import Tuple, Dict, Union, cast, Optional
from functools import partial
import cv2

from tqdm import tqdm

def extract_clip_accident(
    time_of_accident: float,
    time_of_alert: float, 
    video_path: int,
    video_id: str,
    target: bool,
    save_clip_folder: str,
    generate_clips: bool = True,
    resize: Tuple[int, int] = (224, 224),
    N_frames_per_clip: int = 16,
    N_pre_accident_frames: int = 90, N_after_accident_frames: int = 10, 
    ) -> Dict:
    '''
    To extract the frames from `positive` videos.
    accident_time: the true accident time
    
    N_frames_per_clip(int): total number of frames in each clip generated by this function.
    
    N_pre_accident_frames: Number of frames which is the frame before accident frame and will be selected as the last frame of each clip.
    
    N_pre_accident_frames: Number of frames which is the frame after(inclusive) accident frame and will be selected as the last frame of each clip. 
    '''
    def accident_interval(frame:int, last_frame_start:int, last_frame_end:int) -> bool:
        if not target:
            return False
        if frame < min(frame_of_alert, last_frame_start):
            return False
        if  not (last_frame_start <= frame <= last_frame_end):
            return False
        return True
    def nonaccident_interval(frame_of_accident: int, frame: int):
        if target:
            return False
        if frame < frame_of_accident - N_pre_accident_frames:
            return False
        if frame > frame_of_accident + N_after_accident_frames - 1:
            return False

        return True
    if not os.path.isfile(video_path):
        print(f"Can't find this video: {video_path}")
        return
    if not isinstance(video_id, int):
        video_id = int(video_id)
     
    cap = cv2.VideoCapture(video_path)
    last_frame = int(cap.get(cv2.CAP_PROP_FRAME_COUNT)) - 1
    fps = cap.get(cv2.CAP_PROP_FPS) # float
    
    frame_of_accident = int((time_of_accident * fps)) - 1 if target else last_frame//2
    frame_of_alert = int((time_of_alert * fps)) - 1 if target else last_frame//2 
    last_frame_start = max(0, frame_of_accident - N_pre_accident_frames) if target else last_frame
    last_frame_end = min(last_frame, frame_of_accident + N_after_accident_frames - 1) if target else last_frame # reason to add -1 is because of the inclusive of accident frame

    row = []
    frame_index = 0
    cap.set(cv2.CAP_PROP_POS_FRAMES, 0) 
    output_foler = save_clip_folder+f'/video_{video_id:05d}'
    os.makedirs(output_foler, exist_ok = True)
    while True: 
        ret, frame = cap.read()
        if not ret: break
        if frame_index > last_frame_end:break
        frame_id = f'frame_{frame_index:05d}'
        frame_path = os.path.join(output_foler, frame_id+'.jpg')
        if not nonaccident_interval(frame_of_accident, frame_index) and not accident_interval(frame_index, last_frame_start=last_frame_start, last_frame_end = last_frame_end):
            frame_index += 1
            continue
        #if generate_clips:
            #cv2.imwrite(frame_path, cv2.resize(frame, resize), [cv2.IMWRITE_JPEG_QUALITY, 85])
        info = {
            'clip_id': frame_id,
            'video_id': video_id,
            'target': 1 if accident_interval(frame_index, last_frame_start=last_frame_start, last_frame_end = last_frame_end) else 0,
            'weight': 1 if accident_interval(frame_index, last_frame_start=last_frame_start, last_frame_end = last_frame_end) else 1,
            'T_diff': int(max(0, frame_of_accident - frame_index)) if accident_interval(frame_index, last_frame_start=last_frame_start, last_frame_end = last_frame_end)  else -1,
            'frame': int(frame_index),
            'key': f'key_{video_id:05d}_{frame_id}', 
            'accident_frame': int(frame_of_accident) if target else None,
            'concerned': True if ((frame_index == frame_of_accident - 17) or (frame_index == frame_of_accident - 34) or ((frame_index == frame_of_accident - 51))) else False 
        } 
        
        if frame_index < N_frames_per_clip - 1: 
            frame_index += 1      
            continue
        frame_index += 1      
        row.append(info) 
    cap.release()    
    return row

def worker(row_args):
    row, save_clip_folder = row_args
    return extract_clip_accident(row.time_of_event,time_of_alert=row.time_of_alert, target = row.target, video_path = f'dataset/train/{row.id:05d}.mp4', video_id = row.id, save_clip_folder = save_clip_folder) 



def main():
    
    df_after_splitting = pd.read_csv(f'./dataset/sliding_window/{dataset}_videos.csv')
    #print(df_after_splitting)
    save_clip_folder = f'dataset/image/{dataset}' 
    os.makedirs(save_clip_folder, exist_ok=True) 
    print(save_clip_folder)
    info = []
    df_after_splitting["id"] = df_after_splitting["id"].astype(int)
    df_after_splitting["target"] = df_after_splitting["target"].astype(bool)
    
    args_list = [(row, save_clip_folder) for _, row in df_after_splitting.iterrows()]
    
    with Pool(processes = 8) as pool:
        for result in tqdm(pool.imap_unordered(worker, args_list), total = len(args_list)):
            info += result 
    
    #print(info) 
    data_frame = pd.DataFrame.from_dict(info)
    data_frame.to_csv(f'dataset/frame_{dataset}.csv', index = False)
    
    print('Done')
if __name__ == "__main__":
    global  dataset 
    dataset = sys.argv[1]
    main()